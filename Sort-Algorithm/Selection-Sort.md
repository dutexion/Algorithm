# 선택정렬

무작위의 정렬을 오름차순으로 정렬한다고 할 때에,   
선택 정렬이란 정렬 중 가장 작은 것을 선택하여,   
정렬의 가장 앞으로 보내는 것을 의미합니다.

만일 1 10 5 8 7 6 4 3 2 9가 담겨있는 정렬이 있다 할 때에,    
1 10 5 8 7 6 4 3 2 9를 검사하여 가장 작은 값인 1을 가장 앞으로 보내고,    
가장 앞을 제외한 10 5 8 7 6 4 3 2 9를 검사하여 2를 10이 담겨있는 자리에 보내 정렬을 재배치한다.    
( _현재 정렬에는 1 2 5 8 7 6 4 3 10 9 <- 이렇게 담겨있다_ )    
이러한 과정을 반복해주어 1 2 3 4 5 6 7 8 9 10 <- 이렇게 담겨있는 정렬로 만든다.

이것을 c언어 코드로 구현해보자.
```c
#include <stdio.h>

int main()
{
	int i=0, j=0, min=0, index=0, temp=0;
  	int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};
  	for(i = 0; i < 10; i++)
	  {
    	min=9999;
	    for(j = i; j < 10; j++) // 가장 작은 값의 위치 탐색
    	{
    		if(min > array[j])
      		{
        		min = array[j];
        		index = j;
      		}
    	}
    	temp = array[i]; // 정렬 바꿀 값 일시 저장
        array[i] = array[index]; // 바꿀 값이 있는 정렬에 가장 작은 값 넣기
    	array[index] = temp; // 가장 작은 값이 있던 자리에 임시 저장한 값 넣기
  	}
  	for(i = 0; i < 10; i++)
  	{
        printf("%d ",array[i]);
  	}
  	return 0;
}
```

이렇게 코드를 짜면 정상 작동을 하긴 한다.

**하지만** 여기에서 가장 중요한 것은 데이터의 N개일 때 총 몇 번의 비교 연산을 해야 되는지이다.   
선택 정렬은 대략 N * (N+1) / 2번 가량의 연산을 수행해야 한다.   
이를 컴퓨터에서는 가장 큰 차수인 N^2만 보고 "O(N^2)"이라고 표현하곤 한다.

이 말은 한 문단으로 정리하자면   
**선택 정렬의 시간 복잡도는 O(N^2)이다.**    
라는 말이 된다.

다시 말해 정렬해야 할 데이터의 갯수가 10,000개라면 대략 일 억 번 정도 계산을 한다고 가정을 하겠다는 의미이다.    

따라서 선택정렬은 가장 떠올리기 편한 방법이긴 하지만, 효율적이지는 못한 알고리즘이다.
